# -*- coding: utf-8 -*-
"""Final_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JwThLWZWevr1tcJFvPEpvAWhxD0dj9M6
"""

import numpy as np
import matplotlib.pyplot as plt
import random as rd

N = 50000
pi = 0
a = 0.2
b = 0.05
p = 0.1
ze = 0.1
d = 0.0

t = 60
dt = 0.0001
steps = int(t/dt)
x = np.linspace(0,t,steps)

s = np.zeros(steps)
i = np.zeros(steps)
z = np.zeros(steps)
r = np.zeros(steps)

s[0] = N
i[0] = 0
z[0] = 0
r[0] = 0

for j in range(1,steps):
  s[j] = s[j-1] + dt*(pi - b*s[j-1]*z[j-1] - d*s[j-1])
  i[j] = i[j-1] + dt*(b*s[j-1]*z[j-1] - p*i[j-1] - d*i[j-1])
  z[j] = z[j-1] + dt*(p*i[j-1] + ze*r[j-1] - a*s[j-1]*z[j-1])
  r[j] = r[j-1] + dt*(d*s[j-1] + d*i[j-1] + a*s[j-1]*z[j-1] - ze*r[j-1])

plt.plot(x,s)
plt.plot(x,i)
plt.plot(x,z)
plt.plot(x,r)
plt.legend(['Susceptibles','Infected','Zombies','Removed'])
plt.xlabel('Time')
plt.ylabel('Population')

# SIZRB Model

N = 500
pi = 0.1
a = 0.4
b = 0.1
p = 0.1
ze = 0.1
d = 0.0001
o = 0.0999

t = 5000
dt = 0.01
steps = int(t/dt)
x = np.linspace(0,t,steps)

s = np.zeros(steps)
i = np.zeros(steps)
z = np.zeros(steps)
r = np.zeros(steps)
ba = np.zeros(steps)

s[0] = N
i[0] = 0
z[0] = 0
r[0] = 0
ba[0] = 0

for j in range(1,steps):
  s[j] = s[j-1] + dt*(pi*s[j-1] - b*s[j-1]*z[j-1] - d*s[j-1] - o*s[j-1])
  i[j] = i[j-1] + dt*(b*s[j-1]*z[j-1] - p*i[j-1] - d*i[j-1] - o*i[j-1])
  z[j] = z[j-1] + dt*(p*i[j-1] + ze*r[j-1] - a*s[j-1]*z[j-1])
  r[j] = r[j-1] + dt*(d*s[j-1] + d*i[j-1] - ze*r[j-1])
  ba[j] = ba[j-1] + dt*(o*s[j-1] + o*i[j-1] + a*s[j-1]*z[j-1])

plt.plot(x,s)
plt.plot(x,i)
plt.plot(x,z)
plt.plot(x,r)
plt.legend(['Susceptibles','Infected','Zombies','Removed','Banished'])
plt.xlabel('Time')
plt.ylabel('Population')

# Make it to a function
def zombies(pi,a,b,p,ze,d,N,t):
  dt = 0.01
  steps = int(t/dt)
  x = np.linspace(0,t,steps)

  s = np.zeros(steps)
  i = np.zeros(steps)
  z = np.zeros(steps)
  r = np.zeros(steps)

  s[0] = N
  i[0] = 0
  z[0] = 0
  r[0] = 0

  for j in range(1,steps):
    s[j] = s[j-1] + dt*(pi - b*s[j-1]*z[j-1] - d*s[j-1])
    i[j] = i[j-1] + dt*(b*s[j-1]*z[j-1] - p*i[j-1] - d*i[j-1])
    z[j] = z[j-1] + dt*(p*i[j-1] + ze*r[j-1] - a*s[j-1]*z[j-1])
    r[j] = r[j-1] + dt*(d*s[j-1] + d*i[j-1] + a*s[j-1]*z[j-1] - ze*r[j-1])
  return s,i,z,r

# SIZ model on the train good for one way
def trainone(bt,p,g,si,ii,t1,tinterval):
  t = 5
  dt = 0.01
  steps = int(t/dt)
  x = np.linspace(0,t,steps)

  s = np.zeros((steps,int(t1/tinterval)))
  i = np.zeros((steps,int(t1/tinterval)))
  z = np.zeros((steps,int(t1/tinterval)))

  s[0,:] = g*si
  i[0,:] = g*ii
  z[0,:] = 0


  for k in range (int(t1/tinterval)):
    for j in range(1,steps):
      s[j,k] = s[j-1,k] + dt*(-bt*s[j-1,k]*z[j-1,k])
      i[j,k] = i[j-1,k] + dt*(bt*s[j-1,k]*z[j-1,k] - p*i[j-1,k])
      z[j,k] = z[j-1,k] + dt*(p*i[j-1,k])
  return s[-1,:],i[-1,:],z[-1,:]

# SIZ model on the train good for two way
def traintwo(bt,p,g,si,ii):
  t = 5 # This is duration of the train
  dt = 0.01
  steps = int(t/dt)
  x = np.linspace(0,t,steps)

  s = np.zeros(steps)
  i = np.zeros(steps)
  z = np.zeros(steps)

  s[0] = g*si
  i[0] = g*ii
  z[0] = 0


  for j in range(1,steps):
    s[j] = s[j-1] + dt*(-bt*s[j-1]*z[j-1])
    i[j] = i[j-1] + dt*(bt*s[j-1]*z[j-1] - p*i[j-1])
    z[j] = z[j-1] + dt*(p*i[j-1])
  return s[-1],i[-1],z[-1]

# SIZR model for city with the interaction of train (one way)
def zombiestone(pi,a,b,p,ze,d,g,N,st,it,zt,tinterval,firstarrival):
  t=60
  dt = 0.01
  steps = int(t/dt)
  x = np.linspace(0,t,steps)

  s = np.zeros(steps)
  i = np.zeros(steps)
  z = np.zeros(steps)
  r = np.zeros(steps)

  s[0] = N
  i[0] = 0
  z[0] = 0
  r[0] = 0

  timearrive=np.arange(firstarrival,t,tinterval)*100
  for j in range(1,steps):
    if j not in timearrive:
      sadded=0
      iadded=0
      zadded=0
      sgone=0
      igone=0
    else:
      # print('j',j)
      k=int((j-firstarrival)/tinterval/100-1)
      sadded=st[k]
      iadded=it[k]
      zadded=zt[k]
      sgone=s[j-1]
      igone=i[j-1]
      # print('They were passed',sadded,iadded,zadded)
    s[j] = s[j-1] + dt*(pi - b*s[j-1]*z[j-1] - d*s[j-1])-g*sgone+sadded
    i[j] = i[j-1] + dt*(b*s[j-1]*z[j-1] - p*i[j-1] - d*i[j-1])-g*igone+iadded
    z[j] = z[j-1] + dt*(p*i[j-1] + ze*r[j-1] - a*s[j-1]*z[j-1])+zadded
    r[j] = r[j-1] + dt*(d*s[j-1] + d*i[j-1] + a*s[j-1]*z[j-1] - ze*r[j-1])
  return s,i,z,r

# SIZR model for city with the interaction of train (two ways)
def zombiesttwo(pi,a,b,p,ze,d,g,si,ii,zi,ri,N,st,it,zt,tinit,tfinal,tarriv):
  # tinterval is the duration between each train
  # tinit is the starting time of simulation you want (normally the time that train departs)
  # tfinal is the ending time of simulatin you want
  # tarriv is the time that train arrives with respect to the start of simulation (tarriv < tfinal-tinitial)
  # st,it,zt is the S,I,Z from train
  # si,ii,zi,ri is the initial condition of SIZR
  t=tfinal-tinit
  dt = 0.01
  steps = int(t/dt)
  x = np.linspace(0,t,steps)

  s = np.zeros(steps)
  i = np.zeros(steps)
  z = np.zeros(steps)
  r = np.zeros(steps)

  s[0] = si[-1]
  i[0] = ii[-1]
  z[0] = zi[-1]
  r[0] = ri[-1]

  for j in range(1,steps):
    if j ==1:
      # print('j',j)
      sgone=s[j-1]
      igone=i[j-1]
      # Below three lines for train arrives at the same time as it departs
      sadded=st
      iadded=it
      zadded=0
      # sadded=0    Uncomment this and Comment above part if train arrives at a different time from the departure time
      # iadded=0
      # zadded=0
    # elif j == tarriv*100:
    #   sadded=st
    #   iadded=it
    #   zadded=zt
    #   sgone=0
    #   igone=0
    else:
      sadded=0
      iadded=0
      zadded=0
      sgone=0
      igone=0
      # print('They were passed',sadded,iadded,zadded)
    s[j] = s[j-1] + dt*(pi - b*s[j-1]*z[j-1] - d*s[j-1])-g*sgone+sadded
    i[j] = i[j-1] + dt*(b*s[j-1]*z[j-1] - p*i[j-1] - d*i[j-1])-g*igone+iadded
    z[j] = z[j-1] + dt*(p*i[j-1] + ze*r[j-1] - a*s[j-1]*z[j-1])+zadded
    r[j] = r[j-1] + dt*(d*s[j-1] + d*i[j-1] + a*s[j-1]*z[j-1] - ze*r[j-1])
  return s,i,z,r

# Simplified Train Model
# Random pick a fraction of people being infected
def straintwo(g,si,ii):

  ss= g*si
  ia= g*ii
  sif=rd.random()*ss
  iz=rd.random()*ia
  zst= iz
  sst=ss-sif
  ist=ia-iz+sif

  return sst,ist,zst

# Two way train playground
# I make this stepwise process by time. Train runs for 5 mins, and departs every 3 mins.
# Start with first three minutes with no train, and train starts at t=3 for both cities
s11,i11,z11,r11=zombies(0.1,0.1,0.1,0.1,0.1,0.1,500,60)
s12,i12,z12,r12=zombies(0.1,0.1,0.1,0.1,0.1,0.1,300,60)
s1=np.array([])
i1=np.array([])
z1=np.array([])
r1=np.array([])
s2=np.array([])
i2=np.array([])
z2=np.array([])
r2=np.array([])

s1=np.append(s1,s11[0:300])
i1=np.append(i1,i11[0:300])
z1=np.append(z1,z11[0:300])
r1=np.append(r1,r11[0:300])
s2=np.append(s2,s12[0:300])
i2=np.append(i2,i12[0:300])
z2=np.append(z2,z12[0:300])
r2=np.append(r2,r12[0:300])

for i in range (3,60,3):
  if i == 3:
    s21,i21,z21=traintwo(0.2,0.1,0.3,s11[299],i11[299]) #s,i,z 21 is train from city 1 to 2
    s22,i22,z22=traintwo(0.2,0.1,0.1,s12[299],i12[299]) #s,i,z 22 is train from city 2 to 1
    s31,i31,z31,r31=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.1,0.5,s11[0:299],i11[0:299],z11[0:299],r11[0:299],500,s22,i22,z22,i,i+3,0)
    s32,i32,z32,r32=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.1,0.1,s12[0:299],i12[0:299],z12[0:299],r12[0:299],300,s21,i21,z21,i,i+3,0)
    s201=s21 #s,i,z,r 201and202 are for storing values
    i201=i21
    z201=z21
    s202=s22
    i202=i22
    z202=z22
  else:
    s21,i21,z21=traintwo(0.2,0.1,0.5,s31[-1],i31[-1])
    s22,i22,z22=traintwo(0.2,0.1,0.1,s32[-1],i32[-1])
    s31,i31,z31,r31=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.1,0.5,s31,i31,z31,r31,300,s202,i202,z202,i,i+3,2)
    s32,i32,z32,r32=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.1,0.1,s32,i32,z32,r32,300,s201,i201,z201,i,i+3,2)
    s201=s21
    i201=i21
    z201=z21
    s202=s22
    i202=i22
    z202=z22

  s1=np.append(s1,s31)
  i1=np.append(i1,i31)
  z1=np.append(z1,z31)
  r1=np.append(r1,r31)
  s2=np.append(s2,s32)
  i2=np.append(i2,i32)
  z2=np.append(z2,z32)
  r2=np.append(r2,r32)

x=np.linspace(0,60,6000)
plt.plot(x,s1,label='Susceptible')
plt.plot(x,i1,label='Infected')
plt.plot(x,z1,label='Zombies')
plt.plot(x,r1,label='Removed')
plt.title('City 1 Population Dynamics')
# plt.xlim(5,7)
plt.xlabel('t (min)')
plt.ylabel('Population')
plt.legend()
plt.show()
plt.plot(x,s2,label='Susceptible')
plt.plot(x,i2,label='Infected')
plt.plot(x,z2,label='Zombies')
plt.plot(x,r2,label='Removed')
plt.title('City 2 Population Dynamics')
plt.xlabel('t (min)')
plt.ylabel('Population')
plt.legend()
plt.show()

# One way train for 0-60 mins

s1,i1,z1,r1=zombies(0.1,0.1,0.1,0.1,0.1,0.1,500,60)
interval_between_train=3
scity1=s1[interval_between_train*100-1::interval_between_train*100]
icity1=i1[interval_between_train*100-1::interval_between_train*100]
scity1= scity1.reshape(1, len(scity1))
icity1= icity1.reshape(1, len(icity1))
s2,i2,z2=trainone(0.2,0.1,0.1,scity1,icity1,60,3)
s3,i3,z3,r3=zombiestone(0.1,0.1,0.1,0.1,0.1,0.1,0,500,s2,i2,z2,interval_between_train,8)
x=np.linspace(0,60.01,6000)
plt.plot(x,s3,label='Susceptible')
plt.plot(x,i3,label='Infected')
plt.plot(x,z3,label='Zombies')
plt.plot(x,r3,label='Removed')
plt.xlabel('t (min)')
plt.ylabel('Population')
plt.legend()
plt.show()

#Multiple Network
# Here we simplify by ignoring the train. Instead, a fixed fraction of people gS, gI will be picked to other city. And among these people, some will turn into zombie
# A fraction of people will be picked every 5 minutes.
#Generating initial conditions
pickinterval=5
s11,i11,z11,r11=zombies(0.1,0.1,0.1,0.1,0.1,0.1,500,pickinterval)
s12,i12,z12,r12=zombies(0.1,0.1,0.1,0.1,0.1,0.0,500,pickinterval)
s13,i13,z13,r13=zombies(0.1,0.1,0.1,0.1,0.1,0.0,500,pickinterval)
s14,i14,z14,r14=zombies(0.1,0.1,0.1,0.1,0.1,0.0,500,pickinterval)
s15,i15,z15,r15=zombies(0.1,0.1,0.1,0.1,0.1,0.0,500,pickinterval)
s=np.array([])
i=np.array([])
z=np.array([])
r=np.array([])
iniappendlist=np.array([[s11,i11,z11,r11],[s12,i12,z12,r12],[s13,i13,z13,r13],[s14,i14,z14,r14],[s15,i15,z15,r15]])

#Append initial conditions of 5 cities to an array
s=np.append(s,s11)
i=np.append(i,i11)
z=np.append(z,z11)
r=np.append(r,r11)
# print(r)
for k in range (1,5):
  s=np.vstack((s,iniappendlist[k,0]))
  i=np.vstack((i,iniappendlist[k,1]))
  z=np.vstack((z,iniappendlist[k,2]))
  r=np.vstack((r,iniappendlist[k,3]))

for j in range (pickinterval,50,pickinterval):
  # Calculating people that transfers from city a to city b
  s21,i21,z21=straintwo(0.1,0.5*5*s[2,-1]+0.4*2*s[3,-1],0.5*5*i[2,-1]+0.4*2*i[3,-1]) # Added into city 1
  s22,i22,z22=straintwo(0.1,0.4*5*s[2,-1]+0.6*2*s[3,-1]+0.45*4*s[4,-1],0.4*5*i[2,-1]+0.6*2*i[3,-1]+0.45*4*i[4,-1]) # Added into city 2
  s23,i23,z23=straintwo(0.1,0.1*s[0,-1]+0.5*s[1,-1]+0.55*4*s[4,-1],0.1*i[0,-1]+0.5*i[1,-1]+0.55*4*i[4,-1]) # Added into city 3
  s24,i24,z24=straintwo(0.1,0.9*s[0,-1]+0.3*s[1,-1],0.9*i[0,-1]+0.3*i[1,-1]) # Added into city 4
  s25,i25,z25=straintwo(0.1,0.2*s[1,-1]+0.1*5*s[2,-1],0.2*i[1,-1]+0.1*5*i[2,-1]) # Added into city 5
  # Simulating after people added in
  s31,i31,z31,r31=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.0,0.1,s[0,:],i[0,:],z[0,:],r[0,:],500,s21,i21,z21,j,j+pickinterval,0)
  s32,i32,z32,r32=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.0,0.1,s[1,:],i[1,:],z[1,:],r[1,:],500,s22,i22,z22,j,j+pickinterval,0)
  s33,i33,z33,r33=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.0,0.5,s[2,:],i[2,:],z[2,:],r[2,:],500,s23,i23,z23,j,j+pickinterval,0)
  s34,i34,z34,r34=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.0,0.2,s[3,:],i[3,:],z[3,:],r[3,:],500,s24,i24,z24,j,j+pickinterval,0)
  s35,i35,z35,r35=zombiesttwo(0.1,0.1,0.1,0.1,0.1,0.0,0.4,s[4,:],i[4,:],z[4,:],r[4,:],500,s25,i25,z25,j,j+pickinterval,0)
  s=np.vstack((np.concatenate((s[0],s31)),np.concatenate((s[1],s32)),np.concatenate((s[2],s33)),np.concatenate((s[3],s34)),np.concatenate((s[4],s35))))
  i=np.vstack((np.concatenate((i[0],i31)),np.concatenate((i[1],i32)),np.concatenate((i[2],i33)),np.concatenate((i[3],i34)),np.concatenate((i[4],i35))))
  z=np.vstack((np.concatenate((z[0],z31)),np.concatenate((z[1],z32)),np.concatenate((z[2],z33)),np.concatenate((z[3],z34)),np.concatenate((z[4],z35))))
  r=np.vstack((np.concatenate((r[0],r31)),np.concatenate((r[1],r32)),np.concatenate((r[2],r33)),np.concatenate((r[3],r34)),np.concatenate((r[4],r35))))

#Plotting Area
x=np.linspace(0,50,5000)
plt.plot(x,s[0],label='Susceptible')
plt.plot(x,i[0],label='Infected')
plt.plot(x,z[0],label='Zombies')
plt.plot(x,r[0],label='Removed')
plt.title('City 1 Dynamics')
plt.xlabel('t (min)')
plt.ylabel('Population')
plt.legend()
plt.show()
plt.plot(x,s[1],label='Susceptible')
plt.plot(x,i[1],label='Infected')
plt.plot(x,z[1],label='Zombies')
plt.plot(x,r[1],label='Removed')
plt.title('City 2 Dynamics')
plt.xlabel('t (min)')
plt.ylabel('Population')
plt.legend()
plt.show()
plt.plot(x,s[2],label='Susceptible')
plt.plot(x,i[2],label='Infected')
plt.plot(x,z[2],label='Zombies')
plt.plot(x,r[2],label='Removed')
plt.title('City 3 Dynamics')
plt.xlabel('t (min)')
plt.ylabel('Population')
plt.legend()
plt.show()
plt.plot(x,s[3],label='Susceptible')
plt.plot(x,i[3],label='Infected')
plt.plot(x,z[3],label='Zombies')
plt.plot(x,r[3],label='Removed')
plt.title('City 4 Dynamics')
plt.xlabel('t (min)')
plt.ylabel('Population')
plt.legend()
plt.show()
plt.plot(x,s[4],label='Susceptible')
plt.plot(x,i[4],label='Infected')
plt.plot(x,z[4],label='Zombies')
plt.plot(x,r[4],label='Removed')
plt.title('City 5 Dynamics')
plt.xlabel('t (min)')
plt.ylabel('Population')
plt.legend()
plt.show()

# Playground
s1,i1,z1,r1=zombies(0.1,0.1,0.1,0.1,0.1,0.1,500,1)
print(s1[-1])
s2,i2,z2=trainone(0.2,0.1,0.1,s1,i1,50,5)
print(s2[-1])
s3,i3,z3,r3=zombiestone(0.1,0.1,0.1,0.1,0.1,0.1,0,500,s2,i2,z2,5,5)
x=np.linspace(0,50,5000)
plt.plot(x,s3)
plt.plot(x,i3)
plt.plot(x,z3)
plt.plot(x,r3)



s1,i1,z1,r1=zombiest(0.1,0.1,0.1,0.1,0.1,0.1,0.05,500,[0],[0],[0],50)
for j in range (1,11):
  s2,i2,z2=train(0.2,0.1,0.1,s1[j*500-1],i1[j*500-1])
  s3,i3,z3,r3=zombiest(0.1,0.1,0.1,0.1,0.1,0.1,0.05,500,s2,i2,z2,(i+1)*5)

import numpy as np

def eradode(a, b, ze, d, Ti, dt, s1, z1, r1):
    """
    This function will take as inputs the initial values of the 3 classes.
    It will then apply Euler's method to the problem and churn out a vector of
    solutions over a predetermined period of time (the other input).

    Function Inputs:
    s1, z1, r1 - initial value of each ODE, either the actual initial value
                 or the value after the impulse.
    Ti - Amount of time between impulses
    dt - Time step

    """
    k = int(Ti / dt)

    s = np.zeros(k + 1)
    z = np.zeros(k + 1)
    r = np.zeros(k + 1)

    s[0] = s1
    z[0] = z1
    r[0] = r1

    for i in range(k):
        s[i + 1] = s[i] + dt * (-b * s[i] * z[i])  # here we assume birth rate = background death rate, so only term is -b term
        z[i + 1] = z[i] + dt * (b * s[i] * z[i] - a * s[i] * z[i] + ze * r[i])
        r[i + 1] = r[i] + dt * (a * s[i] * z[i] + d * s[i] - ze * r[i])

    return z

import matplotlib.pyplot as plt

def erad(a, b, ze, d, k, T, dt):
    # This is the main function in our numerical impulse analysis, used in
    # conjunction with eradode.py, which will simulate the eradication of
    # zombies. The impulses represent a coordinated attack against zombiekind
    # at specified times.
    # Function Inputs:
    # a - alpha value in model: "zombie destruction" rate
    # b - beta value in model: "new zombie" rate
    # ze - zeta value in model: zombie resurrection rate
    # d - delta value in model: background death rate
    # k - "kill" rate, used in the impulse
    # T - Stopping time
    # dt - time step for numerical solutions
    # Created by Philip Munz, November 21, 2008

    N = 1000
    Ti = T / 4  # We plan to break the solution into 4 parts with 4 impulses
    n = int(Ti / dt)
    m = int(T / dt)
    s = np.zeros(n + 1)
    z = np.zeros(n + 1)
    r = np.zeros(n + 1)
    sol = np.zeros(m + 1)  # The solution vector for all zombie impulses and such
    t = np.zeros(m + 1)
    sl = N
    zl = 0
    rl = 0
    i=0 # i is the intensity factor for the current impulse
    for j in range (0,n,T/dt):
      i=i+1
      t[j:j+n]=np.arange(Ti*(i-1),i*Ti,dt)
      sol[j:j+n]=eradode(a,b,ze,d,Ti,dt,sl,zl,rl)
      sol[j+n]=sol[j+n]-i*k*sol[j+n]
      sl=N-sol[j+n]
      zl=sol[j+n+1]
      rl=0

sol1 = eradode(a, b, ze, d, Ti, dt, s1, z1, r1)
  sol1[n] = sol1[n] - 1 * k * sol1[n]  # 347.7975
  s1 = N - sol1[n]
  z1 = sol1[n]
  r1 = 0

  sol2 = eradode(a, b, ze, d, Ti, dt, s1, z1, r1)
  sol2[n] = sol2[n] - 2 * k * sol2[n]
  s1 = N - sol2[n]
  z1 = sol2[n]
  r1 = 0

  sol3 = eradode(a, b, ze, d, Ti, dt, s1, z1, r1)
  sol3[n] = sol3[n] - 3 * k * sol3[n]
  s1 = N - sol3[n]
  z1 = sol3[n]
  r1 = 0

  sol4 = eradode(a, b, ze, d, Ti, dt, s1, z1, r1)
  sol4[n] = sol4[n] - 4 * k * sol4[n]
  s1 = N - sol4[n]
  z1 = sol4[n]
  r1 = 0

  sol = np.concatenate((sol1[:n], sol2[:n], sol3[:n], sol4))
  t = np.arange(0, T + dt, dt)
  t1 = np.arange(0, Ti + dt, dt)
  t2 = np.arange(Ti, 2 * Ti + dt, dt)
  t3 = np.arange(2 * Ti, 3 * Ti + dt, dt)
  t4 = np.arange(3 * Ti, 4 * Ti + dt, dt)

  plt.figure()
  plt.plot(t1[:n], sol1[:n], 'k')
  plt.plot(t2[:n], sol2[:n], 'k')
  plt.plot(t3[:n], sol3[:n], 'k')
  plt.plot(t4, sol4, 'k')
  plt.show()